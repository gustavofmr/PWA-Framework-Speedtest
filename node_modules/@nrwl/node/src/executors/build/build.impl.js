"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.buildExecutor = void 0;
const project_graph_1 = require("@nrwl/workspace/src/core/project-graph");
const buildable_libs_utils_1 = require("@nrwl/workspace/src/utilities/buildable-libs-utils");
const run_webpack_1 = require("@nrwl/workspace/src/utilities/run-webpack");
const webpack = require("webpack");
const operators_1 = require("rxjs/operators");
const rxjs_for_await_1 = require("rxjs-for-await");
const path_1 = require("path");
const node_config_1 = require("../../utils/node.config");
const config_1 = require("../../utils/config");
const normalize_1 = require("../../utils/normalize");
const generate_package_json_1 = require("../../utils/generate-package-json");
try {
    require('dotenv').config();
}
catch (e) { }
function buildExecutor(rawOptions, context) {
    const { sourceRoot, root } = context.workspace.projects[context.projectName];
    if (!sourceRoot) {
        throw new Error(`${context.projectName} does not have a sourceRoot.`);
    }
    if (!root) {
        throw new Error(`${context.projectName} does not have a root.`);
    }
    const options = normalize_1.normalizeBuildOptions(rawOptions, context.root, sourceRoot, root);
    const projGraph = project_graph_1.createProjectGraph();
    if (!options.buildLibsFromSource) {
        const { target, dependencies } = buildable_libs_utils_1.calculateProjectDependencies(projGraph, context.root, context.projectName, context.targetName, context.configurationName);
        options.tsConfig = buildable_libs_utils_1.createTmpTsConfig(options.tsConfig, context.root, target.data.root, dependencies);
        if (!buildable_libs_utils_1.checkDependentProjectsHaveBeenBuilt(context.root, context.projectName, context.targetName, dependencies)) {
            return { success: false };
        }
    }
    if (options.generatePackageJson) {
        generate_package_json_1.generatePackageJson(context.projectName, projGraph, options);
    }
    const config = options.webpackConfig.reduce((currentConfig, plugin) => {
        return require(plugin)(currentConfig, {
            options,
            configuration: context.configurationName,
        });
    }, node_config_1.getNodeWebpackConfig(options));
    return rxjs_for_await_1.eachValueFrom(run_webpack_1.runWebpack(config, webpack).pipe(operators_1.tap((stats) => {
        console.info(stats.toString(config.stats));
    }), operators_1.map((stats) => {
        return {
            success: !stats.hasErrors(),
            outfile: path_1.resolve(context.root, options.outputPath, config_1.OUT_FILENAME),
        };
    })));
}
exports.buildExecutor = buildExecutor;
exports.default = buildExecutor;
//# sourceMappingURL=build.impl.js.map