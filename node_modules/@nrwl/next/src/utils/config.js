"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareConfig = exports.createWebpackConfig = void 0;
const tslib_1 = require("tslib");
const devkit_1 = require("@nrwl/devkit");
const config_1 = require("next/dist/next-server/server/config");
const path_1 = require("path");
const tsconfig_paths_webpack_plugin_1 = require("tsconfig-paths-webpack-plugin");
const normalize_1 = require("@nrwl/web/src/utils/normalize");
const config_2 = require("@nrwl/web/src/utils/config");
function createWebpackConfig(workspaceRoot, projectRoot, fileReplacements = [], assets = null, nxConfigOptions = {}) {
    return function webpackConfig(config, { isServer, defaultLoaders, }) {
        // default `svgr` to `true`, as it used to be supported by default,
        // before this option was introduced
        if (typeof nxConfigOptions.svgr === 'undefined') {
            nxConfigOptions.svgr = true;
        }
        const mainFields = ['es2015', 'module', 'main'];
        const extensions = ['.ts', '.tsx', '.mjs', '.js', '.jsx'];
        config.resolve.plugins = [
            new tsconfig_paths_webpack_plugin_1.TsconfigPathsPlugin({
                configFile: path_1.resolve(workspaceRoot, projectRoot, 'tsconfig.json'),
                extensions,
                mainFields,
            }),
        ];
        fileReplacements
            .map((fileReplacement) => ({
            replace: path_1.resolve(workspaceRoot, fileReplacement.replace),
            with: path_1.resolve(workspaceRoot, fileReplacement.with),
        }))
            .reduce((alias, replacement) => {
            alias[replacement.replace] = replacement.with;
            return alias;
        }, config.resolve.alias);
        config.module.rules.push({
            test: /\.([jt])sx?$/,
            exclude: /node_modules/,
            use: [defaultLoaders.babel],
        });
        if (nxConfigOptions.svgr) {
            config.module.rules.push({
                test: /\.svg$/,
                oneOf: [
                    // If coming from JS/TS file, then transform into React component using SVGR.
                    {
                        issuer: {
                            test: /\.[jt]sx?$/,
                        },
                        use: [
                            {
                                loader: require.resolve('@svgr/webpack'),
                                options: {
                                    svgo: false,
                                    titleProp: true,
                                    ref: true,
                                },
                            },
                            {
                                loader: require.resolve('url-loader'),
                                options: {
                                    limit: 10000,
                                    name: '[name].[hash:7].[ext]',
                                },
                            },
                        ],
                    },
                ],
            });
        }
        // Copy (shared) assets to `public` folder during client-side compilation
        if (!isServer && Array.isArray(assets) && assets.length > 0) {
            config.plugins.push(config_2.createCopyPlugin(normalize_1.normalizeAssets(assets, workspaceRoot, projectRoot).map((asset) => (Object.assign(Object.assign({}, asset), { output: path_1.join('../public', asset.output) })))));
        }
        return config;
    };
}
exports.createWebpackConfig = createWebpackConfig;
function prepareConfig(phase, options, context) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        const config = (yield config_1.default(phase, options.root, null));
        const userWebpack = config.webpack;
        const userNextConfig = getConfigEnhancer(options.nextConfig, context.root);
        // Yes, these do have different capitalisation...
        config.outdir = `${devkit_1.offsetFromRoot(options.root)}${options.outputPath}`;
        config.distDir =
            config.distDir && config.distDir !== '.next'
                ? config.distDir
                : path_1.join(config.outdir, '.next');
        config.webpack = (a, b) => createWebpackConfig(context.root, options.root, options.fileReplacements, options.assets, config.nx)(userWebpack ? userWebpack(a, b) : a, b);
        if (typeof userNextConfig !== 'function') {
            throw new Error(`Module specified by 'nextConfig' option does not export a function. It should be of form 'module.exports = (phase, config, options) => config;'`);
        }
        return userNextConfig(phase, config, { options });
    });
}
exports.prepareConfig = prepareConfig;
function getConfigEnhancer(pluginPath, workspaceRoot) {
    if (!pluginPath) {
        return (_, x) => x;
    }
    let fullPath;
    try {
        fullPath = require.resolve(pluginPath);
    }
    catch (_a) {
        fullPath = path_1.join(workspaceRoot, pluginPath);
    }
    try {
        return require(fullPath);
    }
    catch (_b) {
        throw new Error(`Could not find file specified by 'nextConfig' option: ${fullPath}`);
    }
}
//# sourceMappingURL=config.js.map